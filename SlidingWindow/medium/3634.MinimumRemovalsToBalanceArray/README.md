# 杂鱼也能快速上手的滑动窗口~附例题

喵~
本文极大参考了灵神（[灵茶山艾府](https://leetcode.cn/u/endlesscheng/ "灵神真神了！") ）在leetcode上的题解和文章，非常感谢！


---

## 什么是滑动窗口？

滑动窗口（Sliding Window）是一种实用的算法技巧，尤其适合处理**数组或字符串的连续子区间问题**。它的核心思想是：

- 用两个指针（`left` 和 `right`）表示一个数组内的子区间，称为一个“窗口”。
- 窗口根据题目条件动态调整左右边界，称为“滑动”，
- 通过一次遍历（O(n)）就能找到符合条件的子区间，避免暴力枚举（O(n²)）的耗时。

滑动窗口常见于：
- 找最长/最短满足条件的子数组
- 计算满足条件的子数组个数
- 涉及“连续”、“子区间”、“最大最小”等关键词的问题

---

## 让数组平衡的最少移除次数

我们用一道例题来讲解这个算法的具体实现方法和适用场合~
原题为[leetcode] (https://leetcode.cn/) [3634. 使数组平衡的最少移除数目](https://leetcode.cn/problems/minimum-removals-to-balance-array/description/?envType=daily-question&envId=2026-02-06)，可以自行前往尝试哦！ 

### 题目简述
给定一个整数数组 `nums` 和一个整数 `k`，你可以移除任意多个元素（但不能删光），目标是让数组变成**平衡的**。

平衡的定义：
- 记数组的最大值为 `max`，最小值为 `min`。
- 如果满足 **max ≤ min × k**，则数组是平衡的。
- 特例：只有一个元素的数组总是平衡的。

求：为了让数组平衡，**最少需要移除多少个元素**。

---

## 为什么想到用滑动窗口？

1. **移除元素只和最大值、最小值有关**，和元素顺序无关，我们自然想到可以**先排序**。
2. 排序后，问题变成：在有序数组中找一个**最长的子数组**，使得子数组的最大值 ≤ 最小值 × k。
3. 找连续区间的最长数组，很容易联想到滑动窗口吧？

所以这就是一道披着排序皮的经典滑动窗口题，思路也就有了：
- 从小到大排序数组
- 用滑动窗口找最长满足条件的子数组
- 移除的元素数 = 总长度 - 子数组长度

---

## 滑动窗口实现详解

我们细化一下上面的思路：
1. 从小到大排序数组
2. 设定 `left = 0`，表示窗口左边界
3. 设定 `right = i`，用`i`遍历数组， 作为窗口右边界
4. 对每个`i`，不断向右移动 `left`，直到 `nums[left] × k ≥ nums[i]`
5. 记录窗口长度 `i - left + 1`，更新最大值
6. 最后用总长度减去最大窗口长度，就是最少移除元素数量



### 代码实现（C++风格）

我们设一个整形left表示窗口左端的位置，初始为0，即数组最左端，再设一个整形length作为窗口长度，这是为了方便后面计算移除元素个数。
窗口右端right就不需要显式定义了，我们把它整合到遍历中完成~
具体而言，每次我们规定一个右端点，然后找到数组内最左侧满足条件的位置作为左端点。条件是什么？很容易想到，就是题意中的max<=min*k，当然，在这里换了个名字。

```cpp
int minRemovals(vector<int>& nums, int k) {
    sort(nums.begin(), nums.end());
    int left = 0;
    int maxLength = 0;
    
    for (int right = 0; right < nums.size(); right++) {
        // 移动 left 直到满足条件
        while (1LL * nums[left] * k < nums[right]) {
            left++;
        }
        // 更新最大窗口长度
        maxLength = max(maxLength, right - left + 1);
    }
    
    // 最少移除数量 = 总长度 - 最长平衡子数组长度
    return nums.size() - maxLength;
}
```

---
###你可能没注意到的一些小问题：

#### 1. 为什么 left 只增不减？
按照我们前面的思路，left不应该每次从0开始逐渐右移，直到满足nums[left] × k ≥ nums[i]吗？
这其实是一个简单的数学问题，因为数组是排序过的！当 `right` 右移，`nums[right]` 变大，条件 `nums[left] × k ≥ nums[right]` 只会越来越容易满足，`left` 只可能向右移动来让条件重新成立。这样保证时间复杂度是 O(n) 而不是 O(n²)。

#### 2. 整数溢出问题
这个板块其实与滑动窗口无关，但作为解题中遇到的问题记录一下：
窝窝第一次提交遇到了这个报错：
```
runtime error: signed integer overflow: 79582 * 61192 cannot be represented in type 'int'
```
也就是`nums[left] × k` 超过了 `int` 的范围。  
解决方法也很简单，在乘积前加上 `1LL`，相当于乘了一个大小为1的long long型，强制转为 `long long` 计算。

```cpp
while (1LL * nums[left] * k < nums[right])
```

---

## 小小的总结

- 滑动窗口适合处理**连续子区间最值问题**。
- 本题通过排序将问题转化为滑动窗口可解的形式。
- 注意数据范围和类型溢出，记得用 `1LL` 保护乘法。
- 最后结果是 `总长度 - 最长窗口长度`，别直接返回窗口长度哦！

---

感谢你看到这里~如果有什么不清楚或疑问的地方，请在评论区告诉我！
我是谜之黑猫神，我想和大家做朋友！
