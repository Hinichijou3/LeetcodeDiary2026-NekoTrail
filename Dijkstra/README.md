# Dijkstra 算法自用详解
喵~
## 算法概述

Dijkstra算法是一种用于计算带权图最短路径的经典算法。它对有向图和无向图都适用，但不能处理负权边。

### 1.1 算法核心思想
Dijkstra算法的核心思路是**贪心策略**。贪心策略就是每一步都采取当前状态下的最优选择，来达到整体的局部最优解的方法。虽然这种方法并不保证所有问题的最优解，但在Dijkstra算法的场景下，它能保证找到单源最短路径。

### 1.2 算法特点
- 仅适用于非负权图
- 时间复杂度：O((V+E)logV)（使用优先队列优化）
- 空间复杂度：O(V+E)

## 二、数据结构设计

### 2.1 邻接表
为了记录图中的连接关系，我们使用邻接表存储结构：

```cpp
vector<vector<pair<int,int>>> g(n);
```

**说明**：
- 每个节点对应一个向量（vector）
- 向量中的每个元素是一个`pair<int, int>`，表示`(邻居节点, 边权值)`
- 这种结构适合存储稀疏图，空间复杂度为O(V+E)

### 2.2 距离数组
为了记录从起点到每个节点的最短距离：

```cpp
vector<int> dis(n, INT_MAX);
dis[0] = 0;  // 起点到自身的距离为0
```

**说明**：
- 初始时，除起点外所有距离设为无穷大（INT_MAX），意为原点不可达其他任何点
- 在算法执行过程中不断更新这些距离值

### 2.3 优先队列
为了实现"每次选择最近节点"的贪心策略：

```cpp
priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
pq.emplace(0, 0);  // 初始元素：(距离, 节点)
```

**为什么使用优先队列（堆）？**
1. **自动排序**：优先队列能自动维护元素的排序，保证每次取出的都是当前距离最小的节点
2. **高效更新**：堆结构支持O(log n)的插入和删除操作
3. **动态维护**：随着算法进行，需要不断添加新的路径可能性

**队列元素说明**：
- 每个元素为`[dis_x, x]`，表示从起点到节点x的当前最短距离为dis_x
- 使用`greater<>`比较器实现最小堆（从小到大排序）
- 值得注意的是，每个元素代表的不是“一个点x和它到原点的距离”，而是“一种原点到这个点x的路径和这条路径的长度”，是一种“走法”。换句话说，x是可能重复的！下面也会提及对这点的处理

## 三、算法执行流程

### 3.1 初始化阶段
1. 创建邻接表`g`，记录图的连接关系
2. 初始化距离数组`dis`，所有值设为INT_MAX，起点设为0
3. 创建优先队列`pq`，将起点`(0, 0)`入队

### 3.2 主循环阶段
算法伪代码描述：
```
while 优先队列不为空:
    1. 取出队首元素(dis_x, x)
    2. 如果x是目标节点，直接返回dis_x（提前终止优化）
    3. 如果dis_x > dis[x]，跳过此元素（避免重复处理）
    4. 遍历x的所有邻居y：
        a. 计算新距离：new_dist = dis_x + weight(x, y)
        b. 如果new_dist < dis[y]：
            i. 更新dis[y] = new_dist
            ii. 将(new_dist, y)加入优先队列
```

### 3.3 一些关键点
1. **提前终止**：当取出目标节点时，可以直接返回结果
2. **跳过旧数据**：如果取出的距离大于当前记录的距离，说明这是“过时”的数据，x以前出堆过！

## 四、完整代码实现

```cpp
vector<int> dis(n, INT_MAX);
dis[0] = 0;

priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
pq.emplace(0, 0);

while (!pq.empty()) {
    auto [dis_x, x] = pq.top();
    pq.pop();
    
    if (x == n - 1) {
        return dis_x;
    }
    
    if (dis_x > dis[x]) {
        continue;
    }
    
    // 遍历当前节点的所有邻居
    for (auto& [y, wt] : g[x]) {
        // 计算通过当前节点到达邻居的新距离
        int new_dist = dis_x + wt;
        
        // 如果路径更短，更新并重入队
        if (dis[y] > new_dist) {
            dis[y] = new_dist;
            pq.emplace(dis[y], y);
        }
    }
}
```

## 五、算法复杂度分析

### 5.1 时间复杂度
- 每个节点最多入队一次：O(V)
- 每条边最多被检查一次：O(E)
- 优先队列操作复杂度：O(log V)
- **总复杂度**：O((V+E)log V)

### 5.2 空间复杂度
- 邻接表存储：O(V+E)
- 距离数组：O(V)
- 优先队列：O(V)
- **总复杂度**：O(V+E)

## 六、算法正确性证明

### 6.1 贪心选择性质
Dijkstra算法的正确性基于以下观察：对于非负权图，全局最短路径中的任意子路径也是最短路径。

### 6.2 数学归纳法证明
**基础情况**：起点到起点的距离为0，显然正确。

**归纳假设**：假设前k个被标记的节点都已找到最短路径。

**归纳步骤**：第k+1个节点是通过优先队列选择的距离最小的节点。假设存在更短的路径，那么这条路径上必然有一个未被标记的节点，这与"距离最小"的贪心选择矛盾。

---
本文极大参考了灵神[（灵茶山艾府）](https://leetcode.cn/u/endlesscheng/ "灵神真神了！")的题解和视频，非常感谢！